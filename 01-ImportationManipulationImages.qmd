---
jupyter: python3
execute:
  echo: true
  eval: false
  message: false
  warning: false
---
# Importation et manipulation de donn√©es spatiales {#sec-chap01}

Dans ce chapitre, nous abordons quelques formats d'images ainsi que leur lecture. Ce chapitre est aussi disponible sous la forme d'un notebook Python:
[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/sfoucher/TraitementImagesPythonVol1/blob/main/notebooks/01-ImportationManipulationImages.ipynb) 

* SciPy ![](https://docs.scipy.org/doc/scipy/_static/logo.svg){width="20pt" fig-align="center"}
* NumPy ![](https://numpy.org/images/logo.svg){width="20pt" fig-align="center"}
* OpenCV
* RasterIO 
* [rioxarray](https://corteva.github.io/rioxarray/stable/index.html)
* xarray ![](https://docs.xarray.dev/en/stable/_static/Xarray_Logo_RGB_Final.svg){height="30pt" fig-align="center"}


Dans l'environnement Google Colab, seul `rioxarray` doit √™tre isntall√©:
```{python}
!pip install -q rioxarray
```

## Importation d'images {#sec-011}

La premi√®re √©tape avant tout traitement est d'acc√©der √† la donn√©e image pour qu'elle soit manipul√©e par le programme Python. L'imagerie satellite pr√©sente certains d√©fis notamment en raison de la taille parfois tr√®s importante des images. Il existe maintenant certaines librairies, comme üîñ[Xarray](https://docs.xarray.dev/en/stable/), qui on cherch√©es √† optimiser la lecture et l'√©criture de grandes images. Il est donc conseiller de toujours garder un oeil sur l'espace m√©moire occup√© par les variables Python reli√©es aux images. La librairie principale en g√©omatique qui va nous permettre d'importer (et d'exporter) de l'imagerie est la librairie [GDAL](https://gdal.org) qui rassemble la plupart des formats sous forme de *driver* (ou pilote en fran√ßais). 

Dans le domaine de la g√©omatique, il faut pr√™ter attention √† trois caract√©ristiques principales des images:
1. **La matrice des donn√©es** elle-m√™me qui contient les valeurs brutes des pixels. Cette matrice sera souvent un cube √† trois dimensions. En Python, ce cube sera le plus souvent un objet de la librairie üîñ[NumPy](https://numpy.org/) (voir section).
2. **La dynamique des images** c.√†.d le format de stockage des valeurs individuelles (octet, entier, double, etc.). Ce format d√©cide principalement de la r√©solution radiom√©trique et des valeurs minimales et maximales support√©es. 
3. **La m√©tadonn√©e** qui va transporter l'information auxiliaire de l'image comme les dimensions et la position de l'image, la date, etc. Cette donn√©e auxiliaire prendra souvent la forme d'un dictionnaire Python. 

Les diff√©rents formats se distinguent principalement sur la mani√®re dont ces trois caract√©ristiques sont g√©r√©es.

### Formats des images

Il existe maintenant de nombreux formats num√©riques pour la donn√©e de type image parfois appel√© donn√©e matricielle ou donn√©e *raster*. La librairie GDAL rassemble la plupart des formats matriciels rencontr√©s en g√©omatique (voir üîñ[Raster drivers ‚Äî GDAL documentation](https://gdal.org/en/latest/drivers/raster/index.html) pour une liste compl√®te).

On peut distinguer deux grandes familles de format:
1. Les formats de type **RVB** issus de l'imagerie num√©rique grand publique comme üîñ[JPEG](https://gdal.org/en/latest/drivers/raster/jpeg.html#raster-jpeg), [png](https://gdal.org/en/latest/drivers/raster/png.html#raster-png), etc. Ces formats ne supportent g√©n√©ralement que trois bandes au maximum (rouge, vert et bleu) et des valeurs de niveaux de gris entre 0 et 255 (format dit 8 bit).
2. **Les g√©o-formats** issus des domaines scientifiques ou techniques comme GeoTIFF, HDF5, etc. qui peuvent inclure plus que trois bandes et des dynamiques plus √©lev√©es (16 bit ou m√™me float).

Les formats RVB restent tr√®s utilis√©s en Python notamment par les librairies dites de vision par ordinateur (*Computer Vision*) comme OpenCV et sickit-image ainsi que les grandes librairies en apprentissage profond (PyTorch, Tensorflow).  

::: bloc_package
::: bloc_package-header
::: bloc_package-icon
:::

**Installation de gdal dans un syst√®me Linux **
:::

::: bloc_package-body
-   Pour installer GDAL¬†:
```
!apt-get update
!apt-get install gdal-bin libgdal-dev
```
:::
:::


#### Formats de type RVB 

Les premiers formats pour de l'imagerie √† une bande (monochrome) et √† trois bandes (image couleur rouge-vert-bleu) sont issus du domaine des sciences de l'ordinateur. On trouvera, entre autres, les formats pbm, png et jpeg. Ces formats supportent peu de m√©tadonn√©es et sont plac√©es dans un ent√™te (*header*) tr√®s limit√©. Cependant, ces formats restent tr√®s populaires dans le domaine de la vision par ordinateur et sont tr√®s utilis√©s en apprentissage profond en particulier. Pour la lecture des images RVB, on peut utiliser les librairies Rasterio, [PIL](https://he-arc.github.io/livre-python/pillow/index.html) ou [OpenCV](https://docs.opencv.org/4.10.0/index.html).

##### Lecture avec la librairie PIL
La librairie PIL retourne un objet de type `PngImageFile`, l'affichage de l'image se fait directement dans la cellule de sortie.

```{python}
#| lst-label: lst-lecture-PIL-PNG
#| lst-cap: Lecture d'une image en format PNG avec PIL
#| eval: true

!wget https://raw.githubusercontent.com/sfoucher/TraitementImagesPythonVol1/refs/heads/main/images/modis-aqua.PNG -O modis-aqua.PNG
from PIL import Image
img = Image.open('modis-aqua.PNG')
img
```

##### Lecture avec la librairie OpenCV
La librairie [OpenCV](https://docs.opencv.org/4.10.0/index.html) est aussi tr√®s populaire en vision par ordinateur. La fonction `imread` donne directement un objet de type NumPy en sortie.

```{python}
#| lst-label: lst-lecture-opencv-PNG
#| lst-cap: Lecture d'une image en format PNG avec OpenCV

!wget https://raw.githubusercontent.com/sfoucher/TraitementImagesPythonVol1/refs/heads/main/images/modis-aqua.PNG -O modis-aqua.PNG
import cv2
img = cv2.imread('modis-aqua.PNG')
img
```
##### Lecture avec la librairie RasterIO

Rien ne nous emp√™che de lire une image de format RVB avec [RasterIO](https://rasterio.readthedocs.io/en/stable/) comme d√©crit dans (@lst-lecturerasterioPNG). Vous noterez cependant les avertissements concernant l'absence de g√©or√©f√©rence pour ce type d'image.

```{python}
#| lst-label: lst-lecturerasterioPNG
#| lst-cap: Lecture d'une image en format PNG avec OpenCV

!wget https://raw.githubusercontent.com/sfoucher/TraitementImagesPythonVol1/refs/heads/main/images/modis-aqua.PNG -O modis-aqua.PNG
import rasterio
img= rasterio.open('modis-aqua.PNG')
img
```

#### Le format GeoTiff 

Le format GeoTIFF est une extension du format TIFF (Tagged Image File Format) qui permet d'incorporer des m√©tadonn√©es g√©ospatiales directement dans un fichier image. D√©velopp√© initialement par Dr. Niles Ritter au Jet Propulsion Laboratory de la [NASA](https://www.earthdata.nasa.gov/esdis/esco/standards-and-practices/geotiff){target="_blank"} dans les ann√©es 1990, GeoTIFF est devenu un standard de facto pour le stockage et l'√©change d'images g√©or√©f√©renc√©es dans les domaines de la t√©l√©d√©tection et des syst√®mes d'information g√©ographique (SIG). Ce format supporte plus que trois bandes aussi longtemps que ces bandes sont de m√™me dimension.

Le format GeoTIFF est tr√®s utilis√© et est largement support√© par les biblioth√®ques et logiciels g√©ospatiaux, notamment [GDAL](https://gdal.org) (*Geospatial Data Abstraction Library*), qui offre des capacit√©s de lecture et d'√©criture pour ce format. Cette compatibilit√© √©tendue a contribu√© √† son adoption g√©n√©ralis√©e dans la communaut√© g√©ospatiale.

##### Standardisation par l'OGC 

Le standard GeoTIFF propos√© par l'Open Geospatial Consortium (OGC) en 2019 formalise et √©tend les sp√©cifications originales du format GeoTIFF, offrant une norme robuste pour l'√©change d'images g√©or√©f√©renc√©es. Cette standardisation, connue sous le nom d'OGC GeoTIFF 1.1 [-@OGCGeoTIFF], apporte plusieurs am√©liorations et clarifications importantes.


#### Le format COG

Une innovation r√©cente dans l'√©cosyst√®me GeoTIFF est le format *Cloud Optimized GeoTIFF* ([COG](http://cogeo.org/)), con√ßu pour faciliter l'utilisation de fichiers GeoTIFF h√©berg√©s sur des serveurs web HTTP. Le COG permet aux utilisateurs et aux logiciels d'acc√©der √† des parties sp√©cifiques du fichier sans avoir √† le t√©l√©charger enti√®rement, ce qui est particuli√®rement utile pour les applications bas√©es sur le cloud.

### M√©tadonn√©es des images 

La mani√®re la plus directe d'acc√©der √† la m√©tadonn√©e d'une image est d'utiliser les commandes üîñ[`rio info`](https://rasterio.readthedocs.io/en/stable/cli.html#info) de la librairie Rasterio ou `gdalinfo` de la librairie `gdal`. Le r√©sultat est imprim√© dans la sortie standard ou sous forme d'un dictionnaire Python.

```{python}
#| lst-label: lst-lecturerasterioPNG
#| lst-cap: Lecture d'une image en format PNG avec OpenCV

!wget https://github.com/sfoucher/TraitementImagesPythonVol1/raw/refs/heads/main/data/chapitre01/subset_RGBNIR_of_S2A_MSIL2A_20240625T153941_N0510_R011_T18TYR_20240625T221903.tif -O RGBNIR_of_S2A.tif

!gdalinfo RGBNIR_of_S2A.tif
```

Le plus simple est d'utiliser la fonction `rio info`:
```{python}
#| lst-label: lst-lecturerasterioPNG
#| lst-cap: Lecture d'une image en format PNG avec OpenCV
#| eval: true

!wget https://github.com/sfoucher/TraitementImagesPythonVol1/raw/refs/heads/main/data/chapitre01/subset_RGBNIR_of_S2A_MSIL2A_20240625T153941_N0510_R011_T18TYR_20240625T221903.tif -q -O RGBNIR_of_S2A.tif

!rio info RGBNIR_of_S2A.tif --indent 2 --verbose
```

## Manipulation des images {#sec-012}

### Manipulation de la matrice de pixels 

La donn√©e brute de l'image est g√©n√©ralement contenue dans un cube matricielle √† trois dimensions (deux dimensions spatiales et une dimension spectrale). Comme expos√© pr√©c√©demment, la librairie dite *"fondationnelle"* pour la manipulation de matrices en Python est [NumPy](https://numpy.org/). Cette librairie contient un nombre tr√®s important de fonctionnalit√©s couvrant l'alg√®bre lin√©aires, les statistiques, etc. et constitue la fondation de nombreuses librairies (voir (@fig-naturenumpy1))

![La librairie NumPy est le fondement de nombreuses librairies scientifiques (d'apr√®s [@NumpyNature]).](https://raw.githubusercontent.com/sfoucher/TraitementImagesPythonVol1/refs/heads/main/images/41586_2020_2649_Fig2_HTML.png){#fig-naturenumpy1 width="100%" fig-align="center"}

### Information de base

Les deux informations de base √† afficher sur une matrice sont 1) les dimensions de la matrice et 2) le format de stockage (le type). Pour cela, on peut utiliser le (@lst-numpyshape), le r√©sultat nous informe que la matrice a 3 dimensions et une taille de `(442, 553, 3)` et un type `uint8` qui repr√©sente 1 octet (8 bit). Par cons√©quent, la matrice a `442` lignes, `553` colonnes et `3` canaux ou bandes. Il faut pr√™ter une attention particuli√®re aux valeurs minimales et maximales tol√©r√©es par le type de la donn√©e comme indiqu√© dans le (@tbl-numpytype) (voir aussi üîñ[Data types ‚Äî NumPy v2.1 Manual](https://numpy.org/doc/stable/user/basics.types.html)).


```{python}
#| lst-label: lst-numpyshape
#| lst-cap: Lecture d'une image en format PNG avec OpenCV
#| eval: true

!wget https://raw.githubusercontent.com/sfoucher/TraitementImagesPythonVol1/refs/heads/main/images/modis-aqua.PNG --quiet -O modis-aqua.PNG
import cv2
img = cv2.imread('modis-aqua.PNG')
print('Nombre de dimensions: ',img.ndim)
print('Dimensions de la matrice: ',img.shape)
print('Type de la donn√©e: ',img.dtype)
```

```{python}
#| label: tbl-numpytype
#| tbl-cap: "Type de donn√©es de NumPy"
#| eval: true

from IPython.display import Markdown
from tabulate import tabulate
table = [["uint8", "char", 8, 0, 255],
        ["int8", "signed char", 8, -127, +128],
        ["uint16", "unsigned short", 16, 0, -32768, +32767],
        ["int16", "short", 16, 0, 655355]]
Markdown(tabulate(table, headers=["dtype", "Nom", "Taille (bits)", "Min", "Max"], tablefmt="pipe"))
```

::: bloc_aller_loin
::: bloc_aller_loin-header
::: bloc_aller_loin-icon
:::

**Les diff√©rents types de donn√©es en dans NumPy**
:::

::: bloc_aller_loin-body
Il comprend des r√©f√©rences ou des extensions d'une m√©thode abord√©e dans une section.
:::
:::

### D√©coupage et indexation de la matrice

L'indexation et le d√©coupage des matrices dans NumPy sont des techniques essentielles pour manipuler efficacement les donn√©es multidimensionnelles en Python, offrant une syntaxe puissante et flexible pour acc√©der et modifier des sous-ensembles sp√©cifiques d'√©l√©ments dans les tableaux (voir @fig-naturenumpy2). Indexer une matrice consiste √† acc√©der √† une valeur dans la matrice pour une position particuli√®re, la syntaxe g√©n√©rale est `matrice[ligne, colonne, bande]` et est similaire √† la manipulation des [listes](https://docs.python.org/fr/3/tutorial/introduction.html#lists) en Python. Les indices commencent √† `0` et se termine √† la `taille-1` de l'axe consid√©r√©. 

![Vue d'ensemble des op√©rations de base des matrices avec NumPy](https://raw.githubusercontent.com/sfoucher/TraitementImagesPythonVol1/refs/heads/main/images/41586_2020_2649_Fig1_HTML.png){#fig-naturenumpy2 width="100%" fig-align="center"}

Le d√©coupage (ou *slicing* en anglais) consiste √† produire une nouvelle matrice qui est un sous-ensemble de la matrice d'origine. Un d√©coupage se fait avec le symbole ':', la syntaxe g√©n√©rale pour d√©finir un d√©coupage est `[d√©but:fin:pas]`. Si on ne sp√©cifie pas `d√©but` ou `fin` alors les valeurs 0 ou `dimension-1` sont consid√©r√©es implicitement. Quelques exemples:
* choisir un pixel en particulier avec toutes les bandes: `matrice[1,1,:]`
* choisir la colonne 2: `matrice[:,2,:]`

La syntaxe de base pour le d√©coupage (*slicing*) des tableaux NumPy repose sur l'utilisation des deux-points (`:`) √† l'int√©rieur des crochets d'indexation. Cette notation permet de s√©lectionner des plages d'√©l√©ments de mani√®re concise et intuitive.
La structure g√©n√©rale du d√©coupage est `matrice[start:stop:step]`, o√π :
1. `start` repr√©sente l'index de d√©part (inclus)
2. `stop` indique l'index de fin (exclu)
3. `step` d√©finit l'intervalle entre chaque √©l√©ment s√©lectionn√©

Si l'un de ces param√®tres est omis, NumPy utilise des valeurs par d√©faut : 0 pour `start`, la taille du tableau pour `stop`, et 1 pour `step`. Par exemple, pour un tableau unidimensionnel `array`, on peut extraire les √©l√©ments du deuxi√®me au quatri√®me avec `array[1:4]`. Pour s√©lectionner tous les √©l√©ments √† partir du troisi√®me, on utiliserait `array[2:]`. Cette syntaxe s'applique √©galement aux tableaux multidimensionnels, o√π chaque dimension est s√©par√©e par une virgule. Ainsi, pour une matrice 2D m, `m[0:2, 1:3]` s√©lectionnerait une sous-matrice 2x2 compos√©e des deux premi√®res lignes et des deuxi√®me et troisi√®me colonnes. L'indexation n√©gative est √©galement support√©e, permettant de compter √† partir de la fin du tableau. Par exemple, `a[-3:]` s√©lectionnerait les trois derniers √©l√©ments d'un tableau.

```{python}
#| eval: true

import cv2
img = cv2.imread('modis-aqua.PNG')
img_col = img[:,1,:]
print('Nombre de dimensions: ',img_col.ndim)
print('Dimensions de la matrice: ',img_col.shape)
```

::: bloc_aller_loin
::: bloc_aller_loin-header
::: bloc_aller_loin-icon
:::

**Une vue versus une copie**
:::

::: bloc_aller_loin-body
Avec NumPy, les manipulations peuvent cr√©er des vues ou des copies. Une vue est une simple repr√©sentation de la m√™me donn√©e originale alors qu'une copie est un nouvel espace m√©moire.

Par d√©faut, un d√©coupage cr√©√© une vue.

On peut v√©rifier si l'espace m√©moire est partag√© avec `np.shares_memory(arr, slice_arr)`.

On peut toujours forcer une copie avec la m√©thode `copy()`
:::
:::
#### Exemple 1: calcul d'un rapport de bande

#### Exemple 2: application d'un filtrage spatial

### Mosa√Øquage, masquage et d√©coupage 

#### Masquage

L'utilisation d'un masque est un outil important en traitement d'image car la plupart des images de t√©l√©d√©tection contiennent des pixels non valides qu'il faut exclure des traitements (ce que l'on appelle le *no data* en Anglais). Il y a plusieurs raison possibles pour la pr√©sence de pixels non valides:
1. L'image est projet√©e dans une grille cartographique et certaines zones, g√©n√©ralement situ√©es en dehors de l'empreinte au sol du capteur, sont √† exclure.
2. La pr√©sence de nuages que l'on veut exclure.
3. La pr√©sence de pixels erron√©s d√ªs √† des probl√®mes de capteurs.
4. La pr√©sence de valeurs non num√©riques (*not a number* ou `nan`)
 

La librairie NumPy fournit des m√©canismes pour exclure automatiquement certaines valeurs.

### Changement de projection cartographique 

### Recalage d'images et co-registration 

## Donn√©es en g√©oscience {#sec-013}

Calibration, unit√©s, donn√©es manquantes, donn√©es √©parses.

netcdf, xarray, GRIB.

Donn√©es m√©t√©os, exemple avec SWOT.

## Importation de donn√©es vectorielles {#sec-012}

### Importation d'un fichier *shapefile* {#sec-0121}

### Importation d'une couche dans un *GeoPackage* {#sec-0122}

### Importation d'une couche dans une *geodatabase* d'ESRI {#sec-0123}

### Importation d'un fichier *shapefile* {#sec-0124}

## Manipulation de donn√©es vectorielles {#sec-014}

### Requ√™tes attributaires 

## Quiz de r√©vision du chapitre {#sec-015}

## Exercices de r√©vision {#sec-016}

::: bloc_exercice
::: bloc_exercice-header
::: bloc_exercice-icon
:::

**Exercice 1.** √Ä compl√©ter
:::

::: bloc_exercice-body
```{python}
#| echo: true 
#| message: false 
#| warning: false 
#| eval: false

# ...
# √† compl√©ter
```

Correction √† la [section @sec-08011].
:::
:::

::: bloc_exercice
::: bloc_exercice-header
::: bloc_exercice-icon
:::

**Exercice 2.** √Ä compl√©ter
:::

::: bloc_exercice-body
```{python}
#| echo: true 
#| message: false 
#| warning: false 
#| eval: false

# ...
# √† compl√©ter
```

Correction √† la [section @sec-08012].
:::
:::

::: bloc_exercice
::: bloc_exercice-header
::: bloc_exercice-icon
:::

**Exercice 3.** √Ä compl√©ter
:::

::: bloc_exercice-body
```{python}
#| echo: true 
#| message: false 
#| warning: false 
#| eval: false

# ...
# √† compl√©ter
```

Correction √† la [section @sec-08013].
:::
:::

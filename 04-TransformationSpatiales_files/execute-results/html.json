{
  "hash": "ee87e6ea83eaf102aa49e562b9f6303a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\njupyter: python3\nexecute:\n  echo: true\n  eval: false\n  message: false\n  warning: false\n---\n\n\n\n\n# Transformations spatiales {#sec-chap04}\n\n\n\n## :rocket: Préambule\n### :dart: Objectifs\nDans ce chapitre, nous abordons quelques techniques de traitement d'images dans le domaine spatial uniquement. Ce chapitre est aussi disponible sous la forme d'un notebook Python sur Google Colab:\n\n[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/sfoucher/TraitementImagesPythonVol1/blob/main/notebooks/04-TransformationSpatiales.ipynb){target=\"_blank\"} \n\n### Librairies\nLes librairies qui vont être explorées dans ce chapitre sont les suivantes:\n* SciPy \n\n* NumPy \n\n* OpenCV\n\n* RasterIO \n\n* Geemap\n\n* [rioxarray](https://corteva.github.io/rioxarray/stable/index.html)\n\n* xarray \n\nDans l'environnement Google Colab, seul `rioxarray` doit être installés:\n\n::: {#eddc3a9c .cell execution_count=1}\n``` {.python .cell-code}\n%%capture\n!pip install -qU rioxarray xrscipy\n```\n:::\n\n\nVérifier les importations:\n\n::: {#128da9d1 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport rioxarray as rxr\nfrom scipy import signal\nimport xarray as xr\nimport xrscipy\n```\n:::\n\n\n### Images utilisées\n\nNous allons utilisez les images suivantes dans ce chapitre:\n\n::: {#109cd686 .cell execution_count=3}\n``` {.python .cell-code}\n!wget https://github.com/sfoucher/TraitementImagesPythonVol1/raw/refs/heads/main/data/chapitre01/subset_RGBNIR_of_S2A_MSIL2A_20240625T153941_N0510_R011_T18TYR_20240625T221903.tif -O RGBNIR_of_S2A.tif\n!wget https://github.com/sfoucher/opengeos-data/raw/refs/heads/main/raster/landsat7.tif -O landsat7.tif\n!wget https://github.com/sfoucher/opengeos-data/raw/refs/heads/main/images/berkeley.jpg -O berkeley.jpg\n```\n:::\n\n\nVérifiez que vous êtes capable de les lire :\n\n::: {#a5097119 .cell execution_count=4}\n``` {.python .cell-code}\nwith rxr.open_rasterio('berkeley.jpg', mask_and_scale= True) as img_rgb:\n    print(img_rgb)\nwith rxr.open_rasterio('RGBNIR_of_S2A.tif', mask_and_scale= True) as img_rgbnir:\n    print(img_rgbnir)\n```\n:::\n\n\n## Analyse fréquentielle\n\nL'analyse fréquentielle, issue du traitement du signal, permet d'avoir un autre point de vue sur les données à partir de ses composantes harmoniques. La modifications des composantes de Fourier modifie l'ensemble de l'image et permet de corriger des problèmes systématiques comme des artefacts ou du bruit de capteur.\n\n### La transformée de Fourier\n\nLa transformée de Fourier permet de transformer une image dans un espace fréquentielle. Cette transformée est complètement reversible. Dans le cas des images numériques, on parle de `2D-FFT` (*2D-Fast Fourier Transform*). \n\nDans le cas d'un signal périodique:\n\n::: {#6aa8e899 .cell execution_count=5}\n``` {.python .cell-code}\narr = xr.DataArray(np.sin(np.linspace(0, 15.7, 30)) ** 2,\n                   dims=('x'), coords={'x': np.linspace(0, 5, 30)})\n```\n:::\n\n\n### Filtrage fréquentielle\n\n\n### L'aliasing\n\n## Filtrage d'image\n\nLe filtrage d'image a plusieurs objectifs en télédétection:\n\n1. La réduction du bruit afin d'améliorer la résolution radiométrique et améliorer la lisibilité de l'image.\n\n2. Le réhaussement de l'image afin d'améliorer le contraste ou faire ressortir les contours.\n\n3. La production de nouvelles caractéristiques: c.à.d dériver de nouvelles images mettant en valeur certaines informations dans l'image comme la texture, les contours, etc.\n\nIl existe de nombreuses méthodes de filtrage dans la littérature, on peut rassembler ces filtres en quatre grandes catégories: \n\n1. Le filtrage peut-être global ou local, c.à.d prendre en compte toute l'image pour filtrer (ex: filtrage par Fourier) ou seulement localement avec une fenêtre ou un voisinage local.  \n\n2. La fonction de filtrage peut-être linéaire ou non linéaire.\n\n3. La fonction de filtrage peut être stationnaire ou adaptative\n\n4. Le filtrage peut-être mono-échelle ou multi-échelles \n\n### Filtrage linéaire stationnaire\n\nUn filtrage linéaire stationnaire consiste à appliquer une même pondération locale des valeurs des pixels dans une fenêtre glissante. La taille de cette fenêtre est généralement impaire (3,5, etc.) afin de définir une position centrale et une fenêtre symétrique.\n \n:::{.callout-note}\nMettre une figure ici\n:::\n\nLe filtre le plus simple est certainement le filtre moyen qui consiste à appliquer le même poids uniforme dans la fenêtre glissante.\n\n$$\nF= \\frac{1}{25}\\left[\n\\begin{array}{c|c|c|c|c}\n1 & 1 & 1 & 1 & 1 \\\\\n\\hline\n1 & 1 & 1 & 1 & 1 \\\\\n\\hline\n1 & 1 & 1 & 1 & 1 \\\\\n\\hline\n1 & 1 & 1 & 1 & 1 \\\\\n\\hline\n1 & 1 & 1 & 1 & 1\n\\end{array}\n\\right]\n$$\n\nEn python, on dispose des fonctions `rolling` et `sliding_window` définis dans la librairie numpy. Par exemple pour le cas du filtre moyen on peut construire une nouvelle vue de l'image avec deux nouvelles  dimensions `x_win` et `y_win`:\n\n::: {#e90f0e10 .cell execution_count=6}\n``` {.python .cell-code}\nimport rioxarray as rxr\nrolling_win = img_rgb.rolling(x=5, y=5,  min_periods= 3, center= True).construct(x=\"x_win\", y=\"y_win\", keep_attrs= True)\nprint(rolling_win[0,0,1,...])\nprint(rolling_win.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<xarray.DataArray (x_win: 5, y_win: 5)> Size: 100B\narray([[ nan,  nan,  nan,  nan,  nan],\n       [ nan,  nan, 209., 210., 209.],\n       [ nan,  nan, 213., 214., 212.],\n       [ nan,  nan, 213., 212., 210.],\n       [ nan,  nan, 210., 209., 206.]], dtype=float32)\nCoordinates:\n    band         int64 8B 1\n    x            float64 8B 1.5\n    y            float64 8B 0.5\n    spatial_ref  int64 8B 0\nDimensions without coordinates: x_win, y_win\n(3, 771, 1311, 5, 5)\n```\n:::\n:::\n\n\nL'avantage de cette approche est qu'il n'y a pas d'utilisation inutile de la mémoire. Noter les `nan` sur les bords de l'image car la fenêtre déborde sur les bordures de l'image. Par la suite un opérateur moyenne peut être appliqué.\n\n::: {#3bf33aad .cell execution_count=7}\n``` {.python .cell-code}\nfiltre_moyen= rolling_win.mean(dim= ['x_win', 'y_win'], skipna= True)\n#print(median_filter)\nfiltre_moyen.astype('int').plot.imshow(rgb=\"band\")\n```\n\n::: {.cell-output .cell-output-display}\n![](04-TransformationSpatiales_files/figure-html/cell-8-output-1.png){}\n:::\n:::\n\n\n:::{.callout-note}\nFiltre de Sobel, filtre Prewitt\n:::\n\n#### Filtrage par convolution\n\nLa façon la plus efficace d'appliquer un filtre linéaire est d'appliquer une convolution. La convolution est généralement très efficace car elle est peut être calculée dans le domaine fréquentielle.\n\n::: {#46b23af5 .cell execution_count=8}\n``` {.python .cell-code}\nscharr = np.array([[ -3-3j, 0-10j,  +3 -3j],\n                   [-10+0j, 0+ 0j, +10 +0j],\n                   [ -3+3j, 0+10j,  +3 +3j]]) # Gx + j*Gy\nprint(img_rgb.isel(band=0).shape)\ngrad = signal.convolve2d(img_rgb.isel(band=0), scharr, boundary='symm', mode='same')\n# on reconstruit un xarray à partir du résultat:\narr = xr.DataArray(np.abs(grad), dims=(\"y\", \"x\"), coords= {'x': img_rgb.coords['x'], 'y': img_rgb.coords['y'], 'spatial_ref': 0})\nprint(arr)\narr.plot.imshow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(771, 1311)\n<xarray.DataArray (y: 771, x: 1311)> Size: 8MB\narray([[  65.96969001,   58.85575588,   54.91812087, ..., 1474.        ,\n        1037.01205393,  389.99487176],\n       [  61.07372594,   39.8246155 ,   89.18520057, ..., 1763.79647352,\n         864.92543031,  270.20362692],\n       [  98.48857802,  112.44554237,  168.10710871, ..., 2110.61365484,\n         870.36658943,  204.40156555],\n       ...,\n       [ 143.17821063,  597.00753764, 2479.42977315, ...,  216.00925906,\n         248.33847869,  200.89798406],\n       [ 106.07544485,  393.67245268, 2188.78824924, ...,  124.96399481,\n         159.90622252,  346.34087255],\n       [  41.59326869,  229.05894438, 1845.1216762 , ...,  175.16278143,\n          33.37663854,  414.3911196 ]])\nCoordinates:\n  * x            (x) float64 10kB 0.5 1.5 2.5 ... 1.308e+03 1.31e+03 1.31e+03\n  * y            (y) float64 6kB 0.5 1.5 2.5 3.5 4.5 ... 767.5 768.5 769.5 770.5\n    spatial_ref  int64 8B 0\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](04-TransformationSpatiales_files/figure-html/cell-9-output-2.png){}\n:::\n:::\n\n\n#### Filtrage par une couche convolutionnelle\n\nUne couche convolutionnelle est simplement un ensemble de filtres appliqués sur la donnée d'entrée. Ce type de filtrage est à la base des réseaux dits convolutionnels qui seront abordés dans le tome 2.\n\n### Filtrage adaptatif\n\nLes filtrages adaptatifs consistent à appliquer un traitement en fonction du contenu local d'une image. Le filtre n'est alors plus stationnaire et sa réponse peut varier en fonction du contenu local.\n\n## Segmentation {#sec-043}\n\n## Vectorisation et rasterisation {#sec-044}\n\n## Analyse de terrain {#sec-045}\n\n### Élévation {#sec-0451}\n### Pente {#sec-0452}\n### Ombrage{#sec-0453}\n### Visibilité {#sec-0454}\n\n\n## Quiz de révision du chapitre {#sec-046}\n\n\n\n## Exercices de révision {#sec-047}\n\n",
    "supporting": [
      "04-TransformationSpatiales_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}
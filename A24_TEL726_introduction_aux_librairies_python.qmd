---
title: "0. \U0001F3AF Objectifs"
jupyter: python3
eval: false
---


1. Introduction aux Notebook Python
2. Introduction Ã  RasterIO


***texte en gras***



```
# Ce texte est au format code
```


```{python}
print('test')
```

# 0. VÃ©rification de l'envirronement et installation de librairies

```{python}
!nvidia-smi
!lscpu
!lsb_release -a
```

```{python}
%%capture --no-stderr
!pip3 -q install  rich typer[all] watermark rasterio
from rich import pretty, print, inspect, traceback
from rich.progress import track
pretty.install()
import logging
from rich.logging import RichHandler

FORMAT = "%(message)s"
logging.basicConfig(level= logging.INFO, format=FORMAT, datefmt="[%X]", handlers=[RichHandler(rich_tracebacks=True)],  # <- not sets rich_tracebacks
)
%load_ext watermark
```

Liste des commandes magiques: https://coderzcolumn.com/tutorials/python/list-of-useful-magic-commands-in-jupyter-notebook-lab

```{python}
%quickref
```

watermark est une commande magique pour vÃ©rifier l'installation des librairies

```{python}
%watermark?
```

```{python}
from watermark import watermark
print(watermark())
```

```{python}
%watermark -p gdal,rasterio,xarray,cv2
```

`%%` permet de changer la fonction de la cellule, par exemple pour passer Ã  un shell:

```{python}
%%bash
ls -l
pwd
```

Le `!` permet d'exÃ©cuter des commandes Linux directement.

Installation de librairies Linux supplÃ©mentaires:

```{python}
!apt install tree
```

```{python}
!tree
```

# 1. Lecture des images
Les deux librairies principales pour lire des images sont:
* GDAL
* RasterIO (basÃ© sur GDAL)

TÃ©lÃ©chargement d'une image Ikonos:

```{python}
#https://drive.google.com/file/d/1_r4etnljaDbF42zNWp_3X0hL6xS5hzaH/view?usp=sharing
#import gdown
#gdown.download(
#        f"https://drive.google.com/uc?export=download&confirm=pbef&id=1_r4etnljaDbF42zNWp_3X0hL6xS5hzaH",
#        '/content/Boston.zip'
#    )
#!unzip -oq /content/Boston.zip -d /content
#img_name = '/content/054947080020_01/054947080020_01_P001_PSH/15SEP16155020-S2AS-054947080020_01_P001.TIF'
```

Il y a la possibilitÃ© aussi de monter votre Google Drive:

```{python}
# This mounts your Google Drive to the Colab VM.
#from google.colab import drive
#drive.mount('/content/drive')
```

## 1.1 Commandes de base de GDAL

La librairie GDAL vient avec une collection de commandes:
https://gdal.org/programs/index.html

```{python}
!apt-get update
!apt-get install gdal-bin libgdal-dev
```

gdalinfo permet d'avoir de l'information sur une image

ðŸ”– __ â€” via [gdalinfo â€” GDAL documentation](https://gdal.org/en/latest/programs/gdalinfo.html)

```{python}
!gdalinfo --help
```

On peut utiliser une variable python dans une commande avec le symbole $

```{python}
img_name = '/content/054947080020_01/054947080020_01_P001_PSH/15SEP16155020-S2AS-054947080020_01_P001.TIF'
!gdalinfo $img_name # rajouter $ pour appeler une variable locale
```

On peut calculer des statistiques :

```{python}
!gdalinfo -stats -nogcp $img_name
```

Le *no data* permet de masquer les valeurs non valides.

On peut fixer la valeur de *no data* via la commande gdalwarp

ðŸ”– __ â€” via [gdalwarp â€” GDAL documentation](https://gdal.org/en/latest/programs/gdalwarp.html)


```{python}
!gdalwarp -dstnodata 0 $img_name /content/output.tif
```

```{python}
!gdalinfo /content/output.tif
#img_name= '/content/output.tif'
```

```{python}
!gdalinfo -stats -nogcp /content/output.tif
```

GDAL vient aussi avec des scripts python:

```{python}
%run  /usr/bin/gdal_calc.py
```

Une opÃ©ration courante est de changer de dynamique radiomÃ©trique, par exemple une onversion en 8 bit :

```{python}
#img_name = '/content/054947080020_01/054947080020_01_P001_PSH/15SEP16155020-S2AS-054947080020_01_P001.TIF'
img_name = '/content/output.tif'
%run  /usr/bin/gdal_calc.py -A $img_name --outfile=/content/output_8bit.tif --allBands=A --overwrite --type=Byte --calc="(A-A.min())/(A.max()-A.min())*254+1" --NoDataValue=0
img_name = '/content/output_8bit.tif'
```

```{python}
!gdalinfo -stats -nogcp /content/output_8bit.tif
```

Il y a d'autres programmes trÃ¨s utiles comme [gdal_translate](https://gdal.org/programs/gdal_translate.html#gdal-translate)

### API Python de gdal (obsolÃ¨te):

```{python}
import gdal, osr

ds = gdal.Open(img_name, gdal.GA_ReadOnly)
assert ds is not None, f"File not found: {img_name}"
```

Vous pouvez afficher les mÃ©thodes de l'objet:

```{python}
type(ds)
```

```{python}
dir(ds)
```

```{python}
inspect(ds, methods=True)
```

```{python}
inspect(ds, all=True)
```

On peut vÃ©rifier la taille de l'image:

```{python}
print("Size is {} x {} x {}".format(ds.RasterXSize,
                                    ds.RasterYSize,
                                    ds.RasterCount))
```

Obtenir la projection du raster et imprimer son code EPSG:

```{python}
prj=ds.GetProjection()
srs=osr.SpatialReference(wkt=prj)
epsg_code= srs.GetAttrValue('authority', 1)
print ("EPSG code: ", epsg_code)
print(f'https://epsg.io/?q={epsg_code}')
```

```{python}
## using GetGeoTransform we can get the upper left X and upper left y coordinates
ulx, xres, xskew, uly, yskew, yres  = ds.GetGeoTransform()
```

```{python}
 ## Calculate lower right x and lower right y we have the coordinates to build a polygon
## these values will be returned and be inputs into build bounds
lrx = ulx + (ds.RasterXSize * xres)
lry = uly + (ds.RasterYSize * yres)
```

```{python}
## rows and columns of the imagery (if needed)
cols = ds.RasterXSize
rows = ds.RasterYSize
```

```{python}
## print it all out to command line
print ("Number of columns: " + str(cols))
print ("Number of rows: " + str(rows))
```

```{python}
print ("___")
print ("upper left x, upper left y, lower right x, lower right y:")
print (ulx)
print (uly)
print (lrx)
print (lry)
```

```{python}
coords = [(ulx,lry), (ulx,uly), (lrx,uly), (lrx,lry)]
print("coords")
print(coords)
```

Conversion vers une matrice de type `numpy.ndarray`:

```{python}
import numpy as np
image = []
target_bands= [1,2,3] # Dans GDAL les bandes commencent Ã  1
for channel in target_bands:
    image_arr = ds.GetRasterBand(channel).ReadAsArray()
    nodatavalue= ds.GetRasterBand(channel).GetNoDataValue()
    assert image_arr is not None, f"Band not found: {channel}"
    image.append(image_arr)
image = np.dstack(image) # transform la liste de matrices en une matrice 3d
ds = None # c'est important de libÃ©rer le fichier une fois utilisÃ©
```

```{python}
type(image)
```

```{python}
print(image.shape)
print(image.dtype)
```

## 1.2 RasterIO

RasterIO emballe GDAL et est plus facile Ã  utiliser.

La librairie Rasterio offre de nombreuses fonctionnalitÃ©s pour manipuler des donnÃ©es raster gÃ©ospatiales en Python. Voici un aperÃ§u de ses principales capacitÃ©s :

### Lecture et Ã©criture de donnÃ©es raster

- Lecture et Ã©criture de nombreux formats de fichiers raster gÃ©ospatiaux (GeoTIFF, NetCDF, JPEG2000, etc.)[1][2]
- AccÃ¨s aux mÃ©tadonnÃ©es des fichiers raster (systÃ¨me de coordonnÃ©es, emprise, rÃ©solution, etc.)[1]
- Lecture et Ã©criture de bandes individuelles ou multiples[5]
- Support de la lecture/Ã©criture par fenÃªtres (portions du raster)[5]

### Manipulation des donnÃ©es

- Conversion des donnÃ©es raster en tableaux NumPy pour faciliter les traitements[1][2]
- RÃ©Ã©chantillonnage et reprojection des donnÃ©es[1]
- Extraction de formes vectorielles Ã  partir de donnÃ©es raster[3]
- Calcul de statistiques sur les donnÃ©es raster[4]

### GÃ©orÃ©fÃ©rencement

- Gestion des systÃ¨mes de coordonnÃ©es et transformations[1]
- Conversion entre coordonnÃ©es image (lignes/colonnes) et coordonnÃ©es gÃ©ographiques[1]

### FonctionnalitÃ©s avancÃ©es

- Support de la lecture/Ã©criture de fichiers volumineux grÃ¢ce Ã  l'accÃ¨s par fenÃªtres[5]
- IntÃ©gration avec d'autres bibliothÃ¨ques scientifiques Python comme NumPy, SciPy, etc.[2]
- Interface en ligne de commande "rio" pour certaines opÃ©rations courantes[2]

### Performance

- Lecture/Ã©criture rapide et efficace des donnÃ©es raster[2]
- Optimisations pour le traitement de grands volumes de donnÃ©es[5]

Rasterio s'appuie sur la bibliothÃ¨que GDAL pour la prise en charge des formats, tout en fournissant une API Python plus intuitive et plus facile Ã  utiliser pour les dÃ©veloppeurs Python[1][2]. Elle est largement utilisÃ©e dans le domaine de la gÃ©omatique et de la tÃ©lÃ©dÃ©tection pour le traitement de donnÃ©es raster gÃ©ospatiales.

**RÃ©fÃ©rences**:

[1] https://rasterio.readthedocs.io/en/stable/

[2] https://pypi.org/project/rasterio/1.3.0.post1/

[3] https://rasterio.readthedocs.io/en/latest/api/rasterio.features.html

[4] https://briques-de-geomatique.readthedocs.io/fr/latest/logiciels-outils.html

[5] https://rasterio.readthedocs.io/en/stable/topics/reading.html

[6] https://briques-de-geomatique.readthedocs.io/fr/latest/format-donnees-import.html

[7] https://rasterio.readthedocs.io/en/stable/quickstart.html

[8] https://rasterio.readthedocs.io/en/stable/installation.html

```{python}
import rasterio
img_name = '/content/output_8bit.tif'
with rasterio.open(img_name) as src:
  print('CRS:',src.crs)
  print('WKT:',src.crs.to_wkt())
  meta = src.meta
  print('nodata: ',src.nodatavals)
  print('meta: ',meta)
  types= {i: dtype for i, dtype in zip(src.indexes, src.dtypes)}
  print(types)
```

`rio info` permet d'obtenir de l'information sur l'image:

```{python}
info = !rio info --indent 2 $img_name
```

```{python}
print('\n'.join(info))
```

```{python}
!rio info --indent 2 $img_name
```

Certains logiciels de traitement d'images en python organisent les tableaux diffÃ©remment de rasterio. L'interprÃ©tation d'un tableau Ã  3 dimensions lu par rasterio est la suivante `(bands, rows, columns)`.

Tandis que les logiciels de traitement d'images comme `scikit-image`, `pillow` et matplotlib sont gÃ©nÃ©ralement commandÃ©s `(rows, columns, bands)`.

```{python}
import rasterio
from rasterio.plot import reshape_as_raster, reshape_as_image
with rasterio.open(img_name) as src:
  raster = src.read()
  print('raster shape: ',raster.shape)

  image = reshape_as_image(raster)
  print('image shape: ',image.shape)

  raster2 = reshape_as_raster(image)
  print('raster shape: ',raster2.shape)
```

On peut visualiser avec matplotlib, observez le systÃ¨me de coordonnÃ©es:

```{python}
import matplotlib.pyplot as plt
plt.imshow?
```

```{python}
import rasterio
import matplotlib.pyplot as plt
with rasterio.open(img_name) as src:
  plt.imshow(src.read(1), cmap='pink')
```

```{python}

from rasterio.plot import show
with rasterio.open(img_name) as src:
  show(src)
```

Consultons l'histogramme des 3 bandes:

```{python}
from rasterio.plot import show_hist

img_name = '/content/054947080020_01/054947080020_01_P001_PSH/15SEP16155020-S2AS-054947080020_01_P001.TIF'
#img_name = '/content/output_8bit.tif'
with rasterio.open(img_name) as src:
  show_hist(
      src, bins=50, lw=0.0, stacked=False, alpha=0.3,
      histtype='stepfilled', title="Histogram")
```

Vous aurez de la difficultÃ© Ã  visualiser en 16 bit:

```{python}
img_name = '/content/054947080020_01/054947080020_01_P001_PSH/15SEP16155020-S2AS-054947080020_01_P001.TIF'
#img_name = '/content/output_8bit.tif'
fig, ax = plt.subplots(figsize=(27,27))
from rasterio.plot import show
with rasterio.open(img_name) as src:
  show(src.read([1,2,3]),transform=src.transform)
```

### Visualisation du masque no-data

```{python}
img_name = '/content/054947080020_01/054947080020_01_P001_PSH/15SEP16155020-S2AS-054947080020_01_P001.TIF'
#img_name = '/content/output_8bit.tif'
with rasterio.open(img_name) as src:
  msk = src.read_masks(1)
  plt.imshow(msk)
```

### Visualisation et passage en 8bit avec numpy:

```{python}
img_name = '/content/054947080020_01/054947080020_01_P001_PSH/15SEP16155020-S2AS-054947080020_01_P001.TIF'
import numpy as np
import rasterio
import matplotlib.pyplot as plt
with rasterio.open(img_name) as src:
  img = src.read()
  print(img.shape)
  img = np.swapaxes(img, 0, 2) # il faut mettre la dimension des bandes en dernier
  print(img.shape)
  print(np.max(img))
  img = 1+254 * (img / float(np.max(img))) # scaling des valeurs entre 0 et 255
  plt.figure(figsize=(10,10))
  plt.imshow(img.astype(np.uint8))
```

# 2. Ã‰galisation d'histogramme

L'Ã©galisation d'histogramme est une technique importante en traitement d'image pour amÃ©liorer le contraste global d'une image. Voici les principes clÃ©s de cette mÃ©thode :

### Principe de base

L'Ã©galisation d'histogramme vise Ã  redistribuer les intensitÃ©s des pixels d'une image de maniÃ¨re plus uniforme sur toute la plage de valeurs disponibles[1][6]. L'objectif est d'obtenir un histogramme plus Ã©quilibrÃ©, ce qui se traduit gÃ©nÃ©ralement par une amÃ©lioration du contraste de l'image.

### Ã‰tapes du processus

1. **Calcul de l'histogramme initial** : On dÃ©termine la distribution des intensitÃ©s de pixels dans l'image d'origine.

2. **Calcul de l'histogramme cumulÃ©** : On calcule l'histogramme cumulÃ©, qui comptabilise pour chaque niveau de gris le nombre total de pixels ayant une intensitÃ© infÃ©rieure ou Ã©gale[4].

3. **Transformation des intensitÃ©s** : On applique une fonction de transformation non linÃ©aire basÃ©e sur l'histogramme cumulÃ© pour modifier les intensitÃ©s des pixels[1].

4. **Redistribution des intensitÃ©s** : Les nouvelles intensitÃ©s sont rÃ©parties sur toute la plage disponible, gÃ©nÃ©ralement de 0 Ã  255 pour une image en niveaux de gris 8 bits[1].

### Effets sur l'image

- **AmÃ©lioration du contraste** : L'Ã©galisation d'histogramme augmente le contraste global de l'image, en particulier pour les images Ã  faible contraste initial[8].

- **Ã‰talement de la dynamique** : Les valeurs d'intensitÃ© sont Ã©talÃ©es sur toute la plage disponible, ce qui peut faire ressortir des dÃ©tails auparavant peu visibles[3].

- **Uniformisation de la distribution** : L'histogramme rÃ©sultant tend vers une distribution plus uniforme, bien que parfaitement plate en pratique[2].

### ConsidÃ©rations importantes

- Cette technique est particuliÃ¨rement efficace pour les images sombres ou Ã  faible contraste.
- Elle peut parfois produire des rÃ©sultats peu naturels ou exagÃ©rer le bruit dans certaines images.
- Pour les images couleur, l'Ã©galisation est gÃ©nÃ©ralement appliquÃ©e sur la composante de luminance uniquement.

En rÃ©sumÃ©, l'Ã©galisation d'histogramme est une mÃ©thode puissante pour amÃ©liorer automatiquement le contraste d'une image en redistribuant ses intensitÃ©s de maniÃ¨re plus uniforme, ce qui peut rÃ©vÃ©ler des dÃ©tails auparavant difficiles Ã  percevoir.

**RÃ©fÃ©rences**:

[1] https://fortierq.github.io/nb/hist_equal/

[2] https://perso.esiee.fr/~perretb/I5FM/TAI/histogramme/index.html

[3] http://bnazarian.free.fr/MyUploads/IN_GBM_03_PRE_TRAITEMENTS.PDF

[4] http://ressources.unit.eu/cours/videocommunication/UNIT_Image%20Processing_nantes/Version%20FR/Chapitre%202/Ressources/Transformation%20d'histogramme/Rchap2_TransfoHisto_FR%5Bfinal%5D.pdf

[5] http://www.normalesup.org/~pmaurel/IMA/CM/ima01_intro_imprimable.pdf

[6] https://fr.wikipedia.org/wiki/Histogramme_(imagerie_num%C3%A9rique)

[7] http://w4.uqo.ca/iglewski/ens/inf4173/2009h/Lariviere_final.pdf

[8] https://fastercapital.com/fr/contenu/Egalisation-de-l-histogramme---equilibre---amelioration-des-images-grace-a-l-egalisation-de-l-histogramme.html

![](https://upload.wikimedia.org/wikipedia/commons/c/ca/Histogrammeinebnung.png)

```{python}
def image_histogram_equalisation(image):
    # get image histogram
    image_histogram, bins = np.histogram(image.flatten(), 256, normed=True)
    cdf = image_histogram.cumsum() # cumulative distribution function
    cdf = (255-1) * cdf / cdf[-1] # normalize
    # use linear interpolation of cdf to find new pixel values
    image_equalized = np.interp(image.flatten(), bins[:-1], cdf)

    return image_equalized.reshape(image.shape).astype('uint8')
```

```{python}
img_he = image_histogram_equalisation(img[:,:,::-1])
```

```{python}
plt.figure(figsize=(10,10))
plt.imshow(img_he)
```

```{python}
import numpy as np
import rasterio
from scipy.stats import norm

def gaussian_cdf(size=256):
    x = np.linspace(-3, 3, size)
    y = norm.cdf(x)
    return y

def cdf(im):
    """
    Computes the CDF of an image
    """
    hist, _ = np.histogram(im.flatten(), 256, [0, 256])
    cdf = hist.cumsum()
    return cdf / cdf[-1]

def hist_matching(c, c_t, im):
    """
    c: CDF of input image
    c_t: CDF of template (Gaussian in this case)
    im: input image
    """
    pixels = np.arange(256)
    new_pixels = np.interp(c, c_t, pixels)
    return new_pixels[im].astype(np.uint8)


# Generate Gaussian CDF
gaussian_cumulative = gaussian_cdf()

img_name = '/content/output_8bit.tif'
import numpy as np
import rasterio
import matplotlib.pyplot as plt
with rasterio.open(img_name) as src:
  image = src.read(1)
  profile = src.profile
  # Compute CDF of the input image
  image_cumulative = cdf(image)

  # Perform histogram matching
  matched = hist_matching(image_cumulative, gaussian_cumulative, image)

# Write the result
profile.update(dtype=rasterio.uint8, count=1)
with rasterio.open('output_image.tif', 'w', **profile) as dst:
    dst.write(matched, 1)

print("Histogram matching completed. Output saved as 'output_image.tif'")
```

```{python}
plt.figure(figsize=(10,10))
plt.imshow(matched)
```


# 3. K-means Classification

```{python}
from sklearn.cluster import KMeans
#import gdal
import numpy as np
```

```{python}
help(KMeans)
```

```{python}
img_he= img.reshape((img.shape[0]*img.shape[1],img.shape[2]))
print(img_he.shape)
```

```{python}
%timeit
km = KMeans(n_clusters=7)
km.fit(img_he)
km.predict(img_he)
```

```{python}
out_dat = km.labels_.reshape((img.shape[0], img.shape[1]))
```

```{python}
plt.figure(figsize=(10,10))
plt.imshow(out_dat)
```

```{python}
with rasterio.open(img_name) as src:
  print('CRS:',src.crs)
  with rasterio.open(
      '/content/new.tif',
      'w',
      driver='GTiff',
      height=out_dat.shape[0],
      width=out_dat.shape[1],
      count=1,
      dtype=out_dat.dtype,
      crs=src.crs,
      transform=src.transform,
  ) as dst_ds:
    dst_ds.write(out_dat, 1)
```

Sauvegarde du fichier:

```{python}
with gdal.Open(img_name, gdal.GA_ReadOnly) as gdst:
  driverTiff = gdal.GetDriverByName('GTiff')
  clfds = driverTiff.Create('/content/classified.tif', gdst.RasterXSize, gdst.RasterYSize, 1, gdal.GDT_Float32)
  clfds.SetGeoTransform(gdst.GetGeoTransform())
  clfds.SetProjection(gdst.GetProjection())
  clfds.GetRasterBand(1).SetNoDataValue(255)
  clfds.GetRasterBand(1).WriteArray(out_dat)
  clfds = None
```

```{python}
with rasterio.open('/content/classified.tif') as src:
  show(src)
```

```{python}
!wget https://github.com/sfoucher/TraitementImagesPythonVol1/raw/refs/heads/main/data/chapitre01/subset_1_of_S2A_MSIL2A_20240625T153941_N0510_R011_T18TYR_20240625T221903_resampled.tif
```

# Xarray
Xarray est une bibliothÃ¨que Python puissante conÃ§ue pour travailler avec des tableaux multidimensionnels Ã©tiquetÃ©s[1][3]. Voici les principales caractÃ©ristiques de Xarray :

### FonctionnalitÃ©s clÃ©s

- **Tableaux Ã©tiquetÃ©s** : Xarray introduit des Ã©tiquettes sous forme de dimensions, coordonnÃ©es et attributs sur des tableaux de type NumPy[3].

- **Structures de donnÃ©es** : Les deux structures de donnÃ©es principales sont DataArray (tableau Ã©tiquetÃ©) et Dataset (collection de DataArrays partageant les mÃªmes coordonnÃ©es)[5].

- **InteropÃ©rabilitÃ©** : Xarray s'intÃ¨gre bien avec l'Ã©cosystÃ¨me scientifique Python, notamment NumPy, Pandas, Dask et Matplotlib[3].

- **OpÃ©rations avancÃ©es** : Elle offre des fonctionnalitÃ©s pour l'analyse et la visualisation de donnÃ©es multidimensionnelles[3].

### Avantages

- **IntuitivitÃ©** : L'utilisation d'Ã©tiquettes rend le code plus lisible et moins sujet aux erreurs[3].

- **FlexibilitÃ©** : Xarray permet de sÃ©lectionner des donnÃ©es par Ã©tiquette plutÃ´t que par position, facilitant la manipulation des donnÃ©es[5].

- **Vectorisation** : Les opÃ©rations mathÃ©matiques sont vectorisÃ©es sur plusieurs dimensions en se basant sur les noms des dimensions[3].

- **E/S efficace** : Xarray prend en charge la lecture et l'Ã©criture de divers formats de donnÃ©es, notamment NetCDF, HDF, Zarr et GRIB[3].

### Utilisation

Xarray est particuliÃ¨rement utile pour travailler avec des donnÃ©es scientifiques multidimensionnelles, comme des sÃ©ries temporelles climatiques ou des images satellite[1]. Elle simplifie considÃ©rablement la manipulation, l'analyse et la visualisation de ces types de donnÃ©es complexes.

En rÃ©sumÃ©, Xarray est un outil puissant qui combine la flexibilitÃ© de Pandas avec la puissance de calcul de NumPy pour les tableaux multidimensionnels, offrant ainsi une solution efficace pour l'analyse de donnÃ©es scientifiques en Python.

Citations:
[1] https://docs.xarray.dev/en/stable/

[2] https://www.data-bird.co/blog/bibliotheque-python

[3] https://xarray.dev

[4] https://openclassrooms.com/fr/courses/7771531-decouvrez-les-librairies-python-pour-la-data-science/7857439-manipulez-le-data-frame

[5] https://docs.xarray.dev/en/stable/getting-started-guide/quick-overview.html

[6] https://docs.python.org/3.7/library/

[7] https://sist.pages.in2p3.fr/webinaire_netcdf_2024/python-xarray.html

[8] https://training.digitalearthafrica.org/fr/latest/python_basics/05_xarray.html

```{python}
!pip install rioxarray
```

```{python}
import rioxarray as xr

ds = xr.open_rasterio(img_name)
ds
```

```{python}
inspect(ds,methods=True)
```

```{python}
ds.band
```

```{python}
#with xr.set_options(display_style="html"):
display(ds)
```

```{python}
da= ds.band
#with xr.set_options(display_style="html"):
display(da)
```

```{python}
ds.dims
```

```{python}
ds.attrs
```

On peut sÃ©lectionner les donnÃ©es directement par *slicing* Ã  la NumPy:

```{python}
ds.data[:30, 20:40]
```

On peut aussi utiliser la fonction `isel` sur le dataset:

```{python}
ds.isel(x=slice(None, 30), y=slice(20, 40))
```

Un autre faÃ§on de faire est d'utiliser les Ã©tiquettes des axes:

```{python}
out= ds.isel(band=1).sel(x=slice(4682000, 4682500,10), y=slice(330500,331000,10))
out
```

```{python}
ds.sel(band=2).sel(y=4686000, method="nearest").plot()
```

```{python}
ds.isel(band=1).plot.imshow()
```

```{python}
ds.plot.imshow(robust=True)
```

